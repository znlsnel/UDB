<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>최적화 기법 - Unity Shader Programming Guide</title>
    <link rel="stylesheet" href="../styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        .content-page {
            background: white;
            min-height: 100vh;
            padding-top: 100px;
        }
        .content-container {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            line-height: 1.7;
        }
        .page-header {
            text-align: center;
            margin-bottom: 3rem;
        }
        .page-title {
            font-size: 2.5rem;
            color: #333;
            margin-bottom: 1rem;
        }
        .page-subtitle {
            font-size: 1.2rem;
            color: #666;
        }
        .back-button {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: #667eea;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 25px;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
            margin-bottom: 2rem;
        }
        .back-button:hover {
            background: #5a67d8;
            transform: translateY(-2px);
        }
        .content-section {
            margin: 2rem 0;
        }
        .section-title {
            font-size: 1.8rem;
            color: #333;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #667eea;
        }
        .subsection-title {
            font-size: 1.4rem;
            color: #667eea;
            margin: 2rem 0 1rem 0;
        }
        .highlight-box {
            background: linear-gradient(135deg, #667eea20, #764ba220);
            border-left: 4px solid #667eea;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }
        .code-example {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-family: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', 'SF Mono', Monaco, 'Inconsolata', 'Roboto Mono', 'Source Code Pro', monospace;
            overflow-x: auto;
            white-space: pre-wrap;
            line-height: 1.6;
            border: 1px solid #333;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .code-example .keyword {
            color: #569cd6;
            font-weight: 500;
        }
        .code-example .string {
            color: #ce9178;
        }
        .code-example .comment {
            color: #6a9955;
            font-style: italic;
        }
        .code-example .type {
            color: #4ec9b0;
        }
        .code-example .number {
            color: #b5cea8;
        }
        .code-example .property {
            color: #9cdcfe;
        }
        .code-example .bracket {
            color: #ffd700;
        }
        .code-example .function {
            color: #dcdcaa;
        }
        .optimization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }
        .optimization-card {
            background: #f8fafc;
            padding: 1.5rem;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
        }
        .optimization-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        .optimization-card h4 {
            color: #667eea;
            margin-bottom: 0.5rem;
            font-size: 1.2rem;
        }
        .optimization-card .optimization-badge {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: #667eea;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        .optimization-card.performance .optimization-badge {
            background: #10b981;
        }
        .optimization-card.memory .optimization-badge {
            background: #3b82f6;
        }
        .optimization-card.bandwidth .optimization-badge {
            background: #f59e0b;
        }
        .optimization-card.instruction .optimization-badge {
            background: #8b5cf6;
        }
        .optimization-card.platform .optimization-badge {
            background: #ef4444;
        }
        .optimization-card.profiling .optimization-badge {
            background: #06b6d4;
        }
        .tip-box {
            background: linear-gradient(135deg, #10b98120, #059f4620);
            border-left: 4px solid #10b981;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }
        .warning-box {
            background: linear-gradient(135deg, #fbbf2420, #f5935420);
            border-left: 4px solid #f59354;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }
        .performance-diagram {
            background: linear-gradient(135deg, #f8fafc, #e2e8f0);
            padding: 2rem;
            border-radius: 12px;
            margin: 2rem 0;
            text-align: center;
            border: 1px solid #cbd5e0;
        }
        .performance-flow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 1rem 0;
        }
        .performance-step {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border: 2px solid #667eea;
            text-align: center;
            flex: 1;
            min-width: 120px;
        }
        .performance-step.measure {
            border-color: #10b981;
            color: #10b981;
        }
        .performance-step.analyze {
            border-color: #3b82f6;
            color: #3b82f6;
        }
        .performance-step.optimize {
            border-color: #f59e0b;
            color: #f59e0b;
        }
        .performance-step.validate {
            border-color: #8b5cf6;
            color: #8b5cf6;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .comparison-table th {
            background: #667eea;
            color: white;
            padding: 1rem;
            text-align: left;
            font-weight: 600;
        }
        .comparison-table td {
            padding: 1rem;
            border-bottom: 1px solid #e2e8f0;
            vertical-align: top;
        }
        .comparison-table tr:hover {
            background: #f8fafc;
        }
        .gpu-architecture {
            background: linear-gradient(135deg, #667eea10, #764ba210);
            padding: 2rem;
            border-radius: 12px;
            margin: 2rem 0;
            text-align: center;
            border: 1px solid #e2e8f0;
        }
        .architecture-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        .architecture-item {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            text-align: center;
        }
        .architecture-item .arch-visual {
            width: 100%;
            height: 60px;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: white;
        }
        .architecture-item.cores .arch-visual {
            background: linear-gradient(45deg, #667eea, #764ba2);
        }
        .architecture-item.memory .arch-visual {
            background: linear-gradient(45deg, #10b981, #059f46);
        }
        .architecture-item.bandwidth .arch-visual {
            background: linear-gradient(45deg, #f59e0b, #d97706);
        }
        .architecture-item.cache .arch-visual {
            background: linear-gradient(45deg, #8b5cf6, #7c3aed);
        }
        .before-after {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }
        .before-after .before,
        .before-after .after {
            background: #f8fafc;
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        .before-after .before h4 {
            color: #ef4444;
            margin-bottom: 1rem;
        }
        .before-after .after h4 {
            color: #10b981;
            margin-bottom: 1rem;
        }
        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }
        .metric-card {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .metric-card .metric-value {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 0.5rem;
        }
        .metric-card .metric-label {
            color: #666;
            font-size: 0.9rem;
        }
        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            gap: 1rem;
        }
        .nav-button {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 25px;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
            flex: 1;
            justify-content: center;
        }
        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }
        .nav-button.prev {
            background: linear-gradient(135deg, #6b7280, #9ca3af);
        }
        .nav-button.prev:hover {
            box-shadow: 0 8px 25px rgba(107, 114, 128, 0.3);
        }
    </style>
</head>
<body>
    <header class="header">
        <nav class="navbar">
            <div class="nav-container">
                <div class="nav-logo">
                    <i class="fas fa-cube"></i>
                    <span>Unity Shader Programming</span>
                </div>
                <ul class="nav-menu">
                    <li class="nav-item">
                        <a href="../index.html" class="nav-link">홈</a>
                    </li>
                    <li class="nav-item">
                        <a href="../index.html#about" class="nav-link">소개</a>
                    </li>
                    <li class="nav-item">
                        <a href="../index.html#contact" class="nav-link">문의</a>
                    </li>
                </ul>
                <div class="hamburger">
                    <span class="bar"></span>
                    <span class="bar"></span>
                    <span class="bar"></span>
                </div>
            </div>
        </nav>
    </header>

    <main class="content-page">
        <div class="content-container">
            <a href="../index.html#table-of-contents" class="back-button">
                <i class="fas fa-arrow-left"></i>
                목차로 돌아가기
            </a>
            
            <div class="page-header">
                <h1 class="page-title">최적화 기법</h1>
                <p class="page-subtitle">셰이더 성능 최적화와 GPU 효율성 향상</p>
            </div>

            <div class="content-section">
                <h2 class="section-title">⚡ 셰이더 최적화의 중요성</h2>
                
                <p><strong>셰이더 최적화</strong>는 게임의 성능과 사용자 경험에 직접적인 영향을 미치는 핵심 요소입니다. GPU의 병렬 처리 특성을 이해하고 효율적인 코드를 작성하는 것이 중요합니다.</p>

                <div class="highlight-box">
                    <strong>🎯 최적화의 핵심 목표:</strong>
                    <ul style="margin-top: 1rem;">
                        <li><strong>프레임레이트 향상:</strong> 안정적인 60fps 이상 유지</li>
                        <li><strong>배터리 수명:</strong> 모바일 기기의 전력 소모 최소화</li>
                        <li><strong>메모리 효율성:</strong> GPU 메모리 사용량 최적화</li>
                        <li><strong>호환성:</strong> 다양한 하드웨어에서 안정적 동작</li>
                    </ul>
                </div>

                <div class="performance-diagram">
                    <h3 style="margin-bottom: 1.5rem; color: #333;">성능 최적화 프로세스</h3>
                    <div class="performance-flow">
                        <div class="performance-step measure">
                            <strong>측정</strong><br>
                            <small>성능 프로파일링</small>
                        </div>
                        <div style="color: #667eea; font-size: 1.5rem;">→</div>
                        <div class="performance-step analyze">
                            <strong>분석</strong><br>
                            <small>병목 지점 파악</small>
                        </div>
                        <div style="color: #667eea; font-size: 1.5rem;">→</div>
                        <div class="performance-step optimize">
                            <strong>최적화</strong><br>
                            <small>코드 개선</small>
                        </div>
                        <div style="color: #667eea; font-size: 1.5rem;">→</div>
                        <div class="performance-step validate">
                            <strong>검증</strong><br>
                            <small>결과 확인</small>
                        </div>
                    </div>
                </div>

                <div class="performance-metrics">
                    <div class="metric-card">
                        <div class="metric-value">60+</div>
                        <div class="metric-label">목표 FPS</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">16.7ms</div>
                        <div class="metric-label">프레임 시간</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">2-4ms</div>
                        <div class="metric-label">GPU 시간</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">512MB</div>
                        <div class="metric-label">메모리 한계</div>
                    </div>
                </div>
            </div>

            <div class="content-section">
                <h2 class="section-title">🏗️ GPU 아키텍처 이해</h2>
                
                <p>효과적인 최적화를 위해서는 GPU의 구조와 동작 방식을 이해해야 합니다.</p>

                <div class="gpu-architecture">
                    <h3 style="margin-bottom: 1.5rem; color: #333;">GPU 아키텍처 구성 요소</h3>
                    <div class="architecture-grid">
                        <div class="architecture-item cores">
                            <div class="arch-visual">🔧</div>
                            <strong>Shader Cores</strong><br>
                            <small>수백~수천 개의 병렬 처리 코어</small>
                        </div>
                        <div class="architecture-item memory">
                            <div class="arch-visual">💾</div>
                            <strong>VRAM</strong><br>
                            <small>고속 그래픽 메모리</small>
                        </div>
                        <div class="architecture-item bandwidth">
                            <div class="arch-visual">🚀</div>
                            <strong>Memory Bandwidth</strong><br>
                            <small>메모리 접근 속도</small>
                        </div>
                        <div class="architecture-item cache">
                            <div class="arch-visual">⚡</div>
                            <strong>Cache</strong><br>
                            <small>L1/L2 캐시 메모리</small>
                        </div>
                    </div>
                </div>

                <h3 class="subsection-title">GPU 병렬 처리 특성</h3>
                
                <div class="code-example">
<span class="comment">// GPU 병렬 처리 이해</span>
<span class="comment">// Warp/Wavefront: 32개 스레드가 동시에 같은 명령어 실행</span>

<span class="comment">// ❌ 비효율적: 분기가 많은 코드</span>
<span class="keyword">if</span> (condition1)
    result = <span class="function">complexCalculation1</span>();
<span class="keyword">else if</span> (condition2)
    result = <span class="function">complexCalculation2</span>();
<span class="keyword">else</span>
    result = <span class="function">complexCalculation3</span>();

<span class="comment">// ✅ 효율적: 분기 최소화</span>
<span class="type">float3</span> result1 = <span class="function">complexCalculation1</span>();
<span class="type">float3</span> result2 = <span class="function">complexCalculation2</span>();
<span class="type">float3</span> result3 = <span class="function">complexCalculation3</span>();

<span class="type">float</span> weight1 = <span class="function">step</span>(<span class="number">0.5</span>, condition1);
<span class="type">float</span> weight2 = <span class="function">step</span>(<span class="number">0.5</span>, condition2) * (<span class="number">1</span> - weight1);
<span class="type">float</span> weight3 = <span class="number">1</span> - weight1 - weight2;

<span class="type">float3</span> result = result1 * weight1 + result2 * weight2 + result3 * weight3;
                </div>

                <div class="tip-box">
                    <strong>💡 GPU 최적화 핵심 원칙:</strong>
                    <ul style="margin-top: 1rem;">
                        <li><strong>분기 최소화:</strong> if문과 반복문 사용 줄이기</li>
                        <li><strong>메모리 접근 패턴:</strong> 연속적인 메모리 접근</li>
                        <li><strong>텍스처 캐시 활용:</strong> 지역성 있는 텍스처 샘플링</li>
                        <li><strong>벡터 연산 활용:</strong> SIMD 명령어 최대 활용</li>
                    </ul>
                </div>
            </div>

            <div class="content-section">
                <h2 class="section-title">🔧 주요 최적화 기법</h2>
                
                <p>실제 개발에서 적용할 수 있는 구체적인 최적화 기법들을 살펴보겠습니다.</p>

                <div class="optimization-grid">
                    <div class="optimization-card performance">
                        <div class="optimization-badge">Performance</div>
                        <h4><i class="fas fa-tachometer-alt"></i> 연산 최적화</h4>
                        <p><strong>수학 함수 최적화:</strong> 빠른 근사 함수 사용</p>
                        <p><strong>벡터 연산:</strong> dot, cross 등 내장 함수 활용</p>
                        <p><strong>상수 폴딩:</strong> 컴파일 타임 계산</p>
                        <p><strong>LUT 활용:</strong> 복잡한 계산을 텍스처로 대체</p>
                    </div>
                    
                    <div class="optimization-card memory">
                        <div class="optimization-badge">Memory</div>
                        <h4><i class="fas fa-memory"></i> 메모리 최적화</h4>
                        <p><strong>텍스처 압축:</strong> DXT, ASTC 등 압축 포맷</p>
                        <p><strong>밉맵 활용:</strong> 거리별 텍스처 해상도 조절</p>
                        <p><strong>텍스처 스트리밍:</strong> 필요한 부분만 로드</p>
                        <p><strong>버퍼 재사용:</strong> 임시 버퍼 풀링</p>
                    </div>
                    
                    <div class="optimization-card bandwidth">
                        <div class="optimization-badge">Bandwidth</div>
                        <h4><i class="fas fa-exchange-alt"></i> 대역폭 최적화</h4>
                        <p><strong>텍스처 샘플링:</strong> 캐시 친화적 접근</p>
                        <p><strong>데이터 패킹:</strong> 여러 값을 하나의 텍스처에</p>
                        <p><strong>LOD 시스템:</strong> 거리별 디테일 조절</p>
                        <p><strong>컬링 기법:</strong> 불필요한 렌더링 제거</p>
                    </div>
                    
                    <div class="optimization-card instruction">
                        <div class="optimization-badge">Instruction</div>
                        <h4><i class="fas fa-microchip"></i> 명령어 최적화</h4>
                        <p><strong>분기 제거:</strong> step, lerp 함수 활용</p>
                        <p><strong>루프 언롤링:</strong> 반복문 최소화</p>
                        <p><strong>정밀도 조절:</strong> half, fixed 타입 사용</p>
                        <p><strong>Dead Code 제거:</strong> 사용하지 않는 코드 정리</p>
                    </div>
                    
                    <div class="optimization-card platform">
                        <div class="optimization-badge">Platform</div>
                        <h4><i class="fas fa-mobile-alt"></i> 플랫폼별 최적화</h4>
                        <p><strong>모바일 GPU:</strong> 타일 기반 렌더링 고려</p>
                        <p><strong>데스크톱 GPU:</strong> 고성능 기능 활용</p>
                        <p><strong>콘솔 최적화:</strong> 하드웨어 특성 활용</p>
                        <p><strong>WebGL 최적화:</strong> 제한사항 고려</p>
                    </div>
                    
                    <div class="optimization-card profiling">
                        <div class="optimization-badge">Profiling</div>
                        <h4><i class="fas fa-chart-line"></i> 프로파일링 도구</h4>
                        <p><strong>Unity Profiler:</strong> CPU/GPU 시간 측정</p>
                        <p><strong>Frame Debugger:</strong> 렌더링 단계 분석</p>
                        <p><strong>GPU 벤더 도구:</strong> NSight, RenderDoc</p>
                        <p><strong>성능 메트릭:</strong> FPS, 메모리, 전력 소모</p>
                    </div>
                </div>
            </div>

            <div class="content-section">
                <h2 class="section-title">📊 실제 최적화 예제</h2>
                
                <p>구체적인 최적화 전후 비교를 통해 실제 성능 향상을 확인해보겠습니다.</p>

                <h3 class="subsection-title">1. 텍스처 샘플링 최적화</h3>
                
                <div class="before-after">
                    <div class="before">
                        <h4>❌ 최적화 전</h4>
                        <div class="code-example">
<span class="comment">// 비효율적인 텍스처 샘플링</span>
<span class="type">float4</span> <span class="function">frag</span>(<span class="type">v2f</span> i) : <span class="keyword">SV_Target</span>
<span class="bracket">{</span>
    <span class="comment">// 매번 새로운 UV 계산</span>
    <span class="type">float2</span> uv1 = i.<span class="property">uv</span> + <span class="function">sin</span>(<span class="property">_Time</span>.<span class="property">y</span>) * <span class="number">0.1</span>;
    <span class="type">float2</span> uv2 = i.<span class="property">uv</span> + <span class="function">cos</span>(<span class="property">_Time</span>.<span class="property">y</span>) * <span class="number">0.1</span>;
    <span class="type">float2</span> uv3 = i.<span class="property">uv</span> + <span class="function">sin</span>(<span class="property">_Time</span>.<span class="property">y</span> * <span class="number">2</span>) * <span class="number">0.05</span>;
    
    <span class="comment">// 개별 텍스처 샘플링</span>
    <span class="type">float4</span> tex1 = <span class="function">tex2D</span>(<span class="property">_MainTex</span>, uv1);
    <span class="type">float4</span> tex2 = <span class="function">tex2D</span>(<span class="property">_NormalMap</span>, uv2);
    <span class="type">float4</span> tex3 = <span class="function">tex2D</span>(<span class="property">_DetailTex</span>, uv3);
    
    <span class="keyword">return</span> tex1 * tex2 * tex3;
<span class="bracket">}</span>
                        </div>
                    </div>
                    <div class="after">
                        <h4>✅ 최적화 후</h4>
                        <div class="code-example">
<span class="comment">// 최적화된 텍스처 샘플링</span>
<span class="type">float4</span> <span class="function">frag</span>(<span class="type">v2f</span> i) : <span class="keyword">SV_Target</span>
<span class="bracket">{</span>
    <span class="comment">// 버텍스 셰이더에서 미리 계산된 UV 사용</span>
    <span class="type">float4</span> tex1 = <span class="function">tex2D</span>(<span class="property">_MainTex</span>, i.<span class="property">uv1</span>);
    <span class="type">float4</span> tex2 = <span class="function">tex2D</span>(<span class="property">_NormalMap</span>, i.<span class="property">uv2</span>);
    <span class="type">float4</span> tex3 = <span class="function">tex2D</span>(<span class="property">_DetailTex</span>, i.<span class="property">uv3</span>);
    
    <span class="comment">// 패킹된 텍스처 활용</span>
    <span class="type">float4</span> packed = <span class="function">tex2D</span>(<span class="property">_PackedTex</span>, i.<span class="property">uv</span>);
    <span class="type">float</span> metallic = packed.<span class="property">r</span>;
    <span class="type">float</span> roughness = packed.<span class="property">g</span>;
    <span class="type">float</span> ao = packed.<span class="property">b</span>;
    
    <span class="keyword">return</span> tex1 * <span class="function">lerp</span>(<span class="number">1</span>, tex2, metallic);
<span class="bracket">}</span>
                        </div>
                    </div>
                </div>

                <h3 class="subsection-title">2. 분기문 최적화</h3>
                
                <div class="before-after">
                    <div class="before">
                        <h4>❌ 최적화 전</h4>
                        <div class="code-example">
<span class="comment">// 분기가 많은 비효율적 코드</span>
<span class="type">float3</span> <span class="function">CalculateLighting</span>(<span class="type">float3</span> normal, <span class="type">float3</span> lightDir)
<span class="bracket">{</span>
    <span class="type">float3</span> result;
    
    <span class="keyword">if</span> (<span class="property">_LightType</span> == <span class="number">0</span>) <span class="bracket">{</span>
        <span class="comment">// Directional Light</span>
        result = <span class="function">dot</span>(normal, lightDir) * <span class="property">_LightColor</span>;
    <span class="bracket">}</span>
    <span class="keyword">else if</span> (<span class="property">_LightType</span> == <span class="number">1</span>) <span class="bracket">{</span>
        <span class="comment">// Point Light</span>
        <span class="type">float</span> distance = <span class="function">length</span>(lightDir);
        <span class="type">float</span> attenuation = <span class="number">1.0</span> / (distance * distance);
        result = <span class="function">dot</span>(normal, <span class="function">normalize</span>(lightDir)) * attenuation * <span class="property">_LightColor</span>;
    <span class="bracket">}</span>
    <span class="keyword">else</span> <span class="bracket">{</span>
        <span class="comment">// Spot Light</span>
        result = <span class="function">CalculateSpotLight</span>(normal, lightDir);
    <span class="bracket">}</span>
    
    <span class="keyword">return</span> result;
<span class="bracket">}</span>
                        </div>
                    </div>
                    <div class="after">
                        <h4>✅ 최적화 후</h4>
                        <div class="code-example">
<span class="comment">// 분기 없는 최적화된 코드</span>
<span class="type">float3</span> <span class="function">CalculateLighting</span>(<span class="type">float3</span> normal, <span class="type">float3</span> lightDir)
<span class="bracket">{</span>
    <span class="comment">// 모든 라이트 타입을 동시에 계산</span>
    <span class="type">float3</span> directional = <span class="function">dot</span>(normal, lightDir) * <span class="property">_LightColor</span>;
    
    <span class="type">float</span> distance = <span class="function">length</span>(lightDir);
    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (<span class="function">max</span>(distance * distance, <span class="number">0.01</span>));
    <span class="type">float3</span> point = <span class="function">dot</span>(normal, <span class="function">normalize</span>(lightDir)) * attenuation * <span class="property">_LightColor</span>;
    
    <span class="type">float3</span> spot = <span class="function">CalculateSpotLightFast</span>(normal, lightDir);
    
    <span class="comment">// 가중치를 사용한 블렌딩</span>
    <span class="type">float3</span> weights = <span class="property">_LightTypeWeights</span>.<span class="property">xyz</span>; <span class="comment">// (directional, point, spot)</span>
    <span class="keyword">return</span> directional * weights.<span class="property">x</span> + point * weights.<span class="property">y</span> + spot * weights.<span class="property">z</span>;
<span class="bracket">}</span>
                        </div>
                    </div>
                </div>

                <h3 class="subsection-title">3. 정밀도 최적화</h3>
                
                <div class="code-example">
<span class="comment">// 정밀도 타입 최적화</span>
<span class="keyword">Shader</span> <span class="string">"Optimized/MobileFriendly"</span>
<span class="bracket">{</span>
    <span class="keyword">Properties</span>
    <span class="bracket">{</span>
        <span class="property">_MainTex</span> (<span class="string">"Texture"</span>, <span class="keyword">2D</span>) = <span class="string">"white"</span> <span class="bracket">{}</span>
        <span class="property">_Color</span> (<span class="string">"Color"</span>, <span class="keyword">Color</span>) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)
    <span class="bracket">}</span>
    
    <span class="keyword">SubShader</span>
    <span class="bracket">{</span>
        <span class="keyword">Pass</span>
        <span class="bracket">{</span>
            <span class="keyword">HLSLPROGRAM</span>
            <span class="keyword">#pragma vertex</span> vert
            <span class="keyword">#pragma fragment</span> frag
            
            <span class="comment">// 모바일 최적화를 위한 정밀도 설정</span>
            <span class="keyword">#ifdef</span> SHADER_API_MOBILE
                <span class="keyword">precision</span> mediump <span class="type">float</span>;
            <span class="keyword">#endif</span>
            
            <span class="keyword">struct</span> <span class="type">appdata</span>
            <span class="bracket">{</span>
                <span class="type">float4</span> vertex : <span class="keyword">POSITION</span>;
                <span class="type">half2</span> uv : <span class="keyword">TEXCOORD0</span>; <span class="comment">// half 정밀도 사용</span>
            <span class="bracket">}</span>;
            
            <span class="keyword">struct</span> <span class="type">v2f</span>
            <span class="bracket">{</span>
                <span class="type">float4</span> vertex : <span class="keyword">SV_POSITION</span>;
                <span class="type">half2</span> uv : <span class="keyword">TEXCOORD0</span>;
                <span class="type">half3</span> worldPos : <span class="keyword">TEXCOORD1</span>; <span class="comment">// half 정밀도로 메모리 절약</span>
            <span class="bracket">}</span>;
            
            <span class="keyword">sampler2D</span> <span class="property">_MainTex</span>;
            <span class="type">half4</span> <span class="property">_Color</span>;
            
            <span class="type">v2f</span> <span class="function">vert</span>(<span class="type">appdata</span> v)
            <span class="bracket">{</span>
                <span class="type">v2f</span> o;
                o.<span class="property">vertex</span> = <span class="function">UnityObjectToClipPos</span>(v.<span class="property">vertex</span>);
                o.<span class="property">uv</span> = v.<span class="property">uv</span>;
                o.<span class="property">worldPos</span> = <span class="function">mul</span>(<span class="property">unity_ObjectToWorld</span>, v.<span class="property">vertex</span>).<span class="property">xyz</span>;
                <span class="keyword">return</span> o;
            <span class="bracket">}</span>
            
            <span class="type">half4</span> <span class="function">frag</span>(<span class="type">v2f</span> i) : <span class="keyword">SV_Target</span>
            <span class="bracket">{</span>
                <span class="comment">// half 정밀도로 계산</span>
                <span class="type">half4</span> tex = <span class="function">tex2D</span>(<span class="property">_MainTex</span>, i.<span class="property">uv</span>);
                <span class="type">half3</span> color = tex.<span class="property">rgb</span> * <span class="property">_Color</span>.<span class="property">rgb</span>;
                
                <span class="comment">// 간단한 거리 기반 페이드</span>
                <span class="type">half</span> distance = <span class="function">length</span>(i.<span class="property">worldPos</span> - <span class="property">_WorldSpaceCameraPos</span>);
                <span class="type">half</span> fade = <span class="function">saturate</span>(<span class="number">1.0</span> - distance * <span class="number">0.1</span>);
                
                <span class="keyword">return</span> <span class="type">half4</span>(color * fade, tex.<span class="property">a</span> * <span class="property">_Color</span>.<span class="property">a</span>);
            <span class="bracket">}</span>
            <span class="keyword">ENDHLSL</span>
        <span class="bracket">}</span>
    <span class="bracket">}</span>
<span class="bracket">}</span>
                </div>
            </div>

            <div class="content-section">
                <h2 class="section-title">📱 플랫폼별 최적화 전략</h2>
                
                <p>각 플랫폼의 특성에 맞는 최적화 전략을 적용해야 합니다.</p>

                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>플랫폼</th>
                            <th>주요 특징</th>
                            <th>최적화 포인트</th>
                            <th>권장 기법</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>모바일 (iOS/Android)</strong></td>
                            <td>타일 기반 GPU, 제한된 메모리</td>
                            <td>전력 소모, 발열 관리</td>
                            <td>half 정밀도, 텍스처 압축, 간단한 셰이더</td>
                        </tr>
                        <tr>
                            <td><strong>PC (Windows/Mac/Linux)</strong></td>
                            <td>고성능 GPU, 충분한 메모리</td>
                            <td>최대 품질, 고해상도</td>
                            <td>복잡한 효과, 고정밀도, 다중 패스</td>
                        </tr>
                        <tr>
                            <td><strong>콘솔 (PS5/Xbox)</strong></td>
                            <td>최적화된 하드웨어</td>
                            <td>하드웨어 특성 활용</td>
                            <td>플랫폼 전용 기능, 메모리 최적화</td>
                        </tr>
                        <tr>
                            <td><strong>WebGL</strong></td>
                            <td>브라우저 제약, OpenGL ES</td>
                            <td>호환성, 로딩 시간</td>
                            <td>간단한 셰이더, 작은 텍스처, 압축</td>
                        </tr>
                        <tr>
                            <td><strong>VR/AR</strong></td>
                            <td>높은 프레임레이트 필수</td>
                            <td>지연시간 최소화</td>
                            <td>고정 프레임레이트, 단순한 효과</td>
                        </tr>
                    </tbody>
                </table>

                <h3 class="subsection-title">모바일 최적화 체크리스트</h3>
                
                <div class="tip-box">
                    <strong>📱 모바일 최적화 필수 사항:</strong>
                    <ul style="margin-top: 1rem;">
                        <li><strong>정밀도:</strong> half/fixed 타입 적극 활용</li>
                        <li><strong>텍스처:</strong> ASTC/ETC2 압축 포맷 사용</li>
                        <li><strong>셰이더:</strong> 복잡한 계산 최소화</li>
                        <li><strong>드로우콜:</strong> 배칭으로 드로우콜 줄이기</li>
                        <li><strong>오버드로우:</strong> 투명 오브젝트 최소화</li>
                        <li><strong>메모리:</strong> 텍스처 크기 최적화</li>
                    </ul>
                </div>
            </div>

            <div class="content-section">
                <h2 class="section-title">🔍 성능 측정 및 프로파일링</h2>
                
                <p>최적화의 효과를 정확히 측정하고 병목 지점을 찾는 것이 중요합니다.</p>

                <h3 class="subsection-title">Unity 프로파일링 도구</h3>
                
                <div class="code-example">
<span class="comment">// 성능 측정을 위한 커스텀 프로파일러</span>
<span class="keyword">using</span> UnityEngine;
<span class="keyword">using</span> Unity.Profiling;

<span class="keyword">public class</span> <span class="type">ShaderProfiler</span> : <span class="type">MonoBehaviour</span>
<span class="bracket">{</span>
    <span class="comment">// 커스텀 프로파일러 마커</span>
    <span class="keyword">static readonly</span> <span class="type">ProfilerMarker</span> s_ShaderExecutionMarker = 
        <span class="keyword">new</span> <span class="type">ProfilerMarker</span>(<span class="string">"Shader.Execution"</span>);
    
    <span class="keyword">static readonly</span> <span class="type">ProfilerMarker</span> s_TextureSamplingMarker = 
        <span class="keyword">new</span> <span class="type">ProfilerMarker</span>(<span class="string">"Shader.TextureSampling"</span>);
    
    <span class="keyword">public</span> <span class="type">Material</span> testMaterial;
    <span class="keyword">public</span> <span class="type">int</span> testIterations = <span class="number">1000</span>;
    
    <span class="keyword">void</span> <span class="function">Update</span>()
    <span class="bracket">{</span>
        <span class="comment">// GPU 시간 측정</span>
        <span class="keyword">using</span> (s_ShaderExecutionMarker.<span class="function">Auto</span>())
        <span class="bracket">{</span>
            <span class="function">TestShaderPerformance</span>();
        <span class="bracket">}</span>
        
        <span class="comment">// 메모리 사용량 체크</span>
        <span class="type">long</span> gpuMemory = <span class="type">Profiler</span>.<span class="function">GetAllocatedMemoryForGraphicsDriver</span>();
        <span class="type">Debug</span>.<span class="function">Log</span>(<span class="string">$"GPU Memory: {gpuMemory / 1024 / 1024} MB"</span>);
    <span class="bracket">}</span>
    
    <span class="keyword">void</span> <span class="function">TestShaderPerformance</span>()
    <span class="bracket">{</span>
        <span class="comment">// 셰이더 성능 테스트</span>
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i < testIterations; i++)
        <span class="bracket">{</span>
            <span class="keyword">using</span> (s_TextureSamplingMarker.<span class="function">Auto</span>())
            <span class="bracket">{</span>
                <span class="comment">// 텍스처 샘플링 테스트</span>
                testMaterial.<span class="function">SetFloat</span>(<span class="string">"_TestValue"</span>, <span class="type">Time</span>.<span class="property">time</span>);
            <span class="bracket">}</span>
        <span class="bracket">}</span>
    <span class="bracket">}</span>
    
    <span class="keyword">void</span> <span class="function">OnGUI</span>()
    <span class="bracket">{</span>
        <span class="comment">// 실시간 성능 정보 표시</span>
        <span class="type">GUILayout</span>.<span class="function">Label</span>(<span class="string">$"FPS: {1.0f / Time.deltaTime:F1}"</span>);
        <span class="type">GUILayout</span>.<span class="function">Label</span>(<span class="string">$"Frame Time: {Time.deltaTime * 1000:F2}ms"</span>);
        <span class="type">GUILayout</span>.<span class="function">Label</span>(<span class="string">$"Triangles: {UnityStats.triangles}"</span>);
        <span class="type">GUILayout</span>.<span class="function">Label</span>(<span class="string">$"Draw Calls: {UnityStats.drawCalls}"</span>);
    <span class="bracket">}</span>
<span class="bracket">}</span>
                </div>

                <div class="warning-box">
                    <strong>⚠️ 프로파일링 주의사항:</strong>
                    <ul style="margin-top: 1rem;">
                        <li><strong>실제 기기 테스트:</strong> 에디터와 실제 성능 차이 고려</li>
                        <li><strong>다양한 시나리오:</strong> 최악의 경우도 테스트</li>
                        <li><strong>지속적 모니터링:</strong> 개발 과정 전반에 걸친 측정</li>
                        <li><strong>목표 설정:</strong> 명확한 성능 목표 수립</li>
                    </ul>
                </div>
            </div>

            <div class="navigation-buttons">
                <a href="post-processing.html" class="nav-button prev">
                    <i class="fas fa-chevron-left"></i>
                    이전: 포스트 프로세싱
                </a>
                <a href="../index.html#table-of-contents" class="nav-button">
                    목차로 돌아가기
                    <i class="fas fa-home"></i>
                </a>
            </div>
        </div>
    </main>

    <script src="../script.js"></script>
</body>
</html> 